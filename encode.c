#include <stdio.h>#include <stdlib.h>#define BUFFER_SIZE 102400#define TRUE 1#define FALSE 0typedef unsigned char byte;  //Check this out!!!unsigned char buffer[BUFFER_SIZE];int encode(FILE *fp, unsigned char *data, int dsize, int dic_bits, int code_bits);/*main function*/int main(int ac, char *av[]){	FILE *fp_i, *fp_o;	int i,c;	int dic,code;	printf("---TEST1---\n");	if(ac < 5){		printf("ERROR:Not enough arguments\n");		exit(8); //入力引数が足りない	}	fp_i = fopen(av[1],"r");//	fp_i = fopen(av[1],"rb");		if(fp_i == NULL){		fprintf(stderr, "Can not open Input File\n");		exit(8);	}	i = 0;	while(i < BUFFER_SIZE && (c = fgetc(fp_i)) != EOF){		buffer[i] = c;		i++;	}	fclose(fp_i);	fp_o = fopen(av[2],"w"); //wb	if(fp_o == NULL){		fprintf(stderr, "Can not find Output File");		exit(8);	}	dic = atoi(av[3]); 	code = atoi(av[4]);	printf("dic=%d, code = %d\n",dic,code);	encode(fp_o,buffer,i,dic,code);	fclose(fp_o);	printf("---TEST2---\n");}/*４バイトの数値データをファイル出力する*/int fputLong(long num, FILE *fp){	fputc((num >> 24) & 0xff,fp);  /*num を24ビット分右シフト 16進数->0xFF=(1111 1111)2=(255)10*/	fputc((num >> 16) & 0xff,fp);	fputc((num >> 8) & 0xFF ,fp);	fputc(num			   	,fp);	return 0;		}static int bits = 0;  //外のファイルから参照不可static int bdata = 0;/*出力処理の初期化*/int fputBitInit(){	bits = 0;	bdata = 0;	return 0;}/*1bit出力*/int fputBit(int bit, FILE *fp){	bdata = (bdata << 1) | bit;	bits ++;	if(bits >= 8){		fputc(bdata,fp);		bits = 0;		bdata = 0;	}	return 0;}/*nビット出力*/int putBits(FILE *fp, int data,int n){	int i;	for(i = n-1; i >= 0; i--){		fputBit((data >> i) & 1 , fp);	}	return 0;}/*余ったビット出力*/int flushBit(FILE *fp){	int i;	for(i = 0; i < 7; i++)		fputBit(0,fp);	return 0;}/*辞書バッファ*/typedef int BUF;typedef struct  SDIC{	BUF *buffer;	int dic_len, code_len; 		//辞書サイズとコードサイズ	int buf_size; 				//バッファの全体のサイズ	int dic_bgn; 				//辞書部分の始まり	int code_bgn, code_end;		//コード部分の始まりと終わり}SlideDic;/*Slide辞書中の次のデータ位置を求める*/int nextPos(int now, int bsize){	return (now + 1) % bsize;}/*辞書バッファの初期化*/int initSlideDic(SlideDic *sdic, int dic, int code){	int i;	int size;	size = dic + code;	if((sdic->buffer = malloc(sizeof(BUF)*size)) == NULL) 		return FALSE;	for(i = 0; i < size; i++) 		sdic->buffer[i] = 0;	sdic->dic_len = dic;	sdic->code_len = code;	sdic->dic_bgn = 0;	sdic->code_bgn = 0;	sdic->code_end = 0;	return TRUE;}/*辞書のpos番目から一致する長さを求める*/int getMatchLength(SlideDic *sdic, int pos){	int len;	int codes;	int i;	int t,u;	len = 0;	t = pos;	u = sdic->code_bgn;	codes = sdic->code_end - sdic->code_bgn;	if(codes < 0)		codes += sdic->buf_size;	for(i = 0; i < codes; i++){		if(sdic->buffer[t] != sdic->buffer[u]) 			break;		len++;		t = nextPos(t,sdic->buf_size);		u = nextPos(u,sdic->buf_size);	}	return len;}/*一致文字列の最も長いものを辞書から探す*//*pos, lenにそれぞれ位置、長さを返す*/int getMatchPattern(SlideDic *sdic, int *pos, int *len){	int i;	int len1;	*pos = -1;	*len = -1;	for(i = sdic->dic_bgn; i!=sdic->code_bgn; i = nextPos(i, sdic->buf_size)){		len1 = getMatchLength(sdic,i);		if(*len < len1){			*len = len1;			*pos = i - sdic->dic_bgn;		}	}	if(*pos < 0) 		*pos += sdic->buf_size;	return 0;}/*辞書バッファに１文字追加*/int insertCodeToDic(SlideDic *sdic, int c){	int bsize;	bsize = sdic->buf_size;	sdic->buffer[sdic->code_end] = c;	sdic->code_end = nextPos(sdic->code_end,bsize);	return 0;}/*辞書バッフアのスライド*/int slideDic(SlideDic *sdic){	int dic_next;	int dic_size;	dic_size = sdic->code_bgn - sdic->dic_bgn;	if(dic_size < 0)		dic_size += sdic->buf_size;	sdic->code_bgn = nextPos(sdic->code_bgn,sdic->buf_size);	if(dic_size >= sdic->dic_len){		dic_next = nextPos(sdic->dic_bgn, sdic->buf_size);		sdic->dic_bgn = dic_next;	}	return 0;}/*2のx乗を求める*/int getPow2(int x){	int i;	int s;	s = 1;	for (i = 0; i < x; i++) s *=2;	return s;	}/*記録するのに必要な最小ビット長を求める*/int getBitLength(int x){	if(x < 2) return 1;	if(x < 4) return 2;	if(x < 8) return 3;	if(x < 16) return 4;			if(x < 32) return 5;				if(x < 64) return 6;				if(x < 128) return 7;				if(x < 256) return 8;			if(x < 512) return 9;				if(x < 1024) return 10;					if(x < 2048) return 11;						if(x < 4096) return 12;						if(x < 8192) return 13;						if(x < 16384) return 14;							if(x < 32768) return 15;							if(x < 65536) return 16;								printf("ERROR!!!");	return -1;}/*圧縮処理メイン*/int encode(FILE *fp, unsigned char *data, int dsize, int dic_bits, int code_bits){	SlideDic sdic;	int dic,code;	int init_size;	int pos,len;	int i,p;//	printf("Test Passed\n");	dic = getPow2(dic_bits);	code = getPow2(code_bits) + 2;	initSlideDic(&sdic, dic,code);	if(dsize < code) init_size = dsize;	else init_size = code;	p = 0;	for(i = 0; i < init_size; i++){		insertCodeToDic(&sdic,data[p++]);	}	fputLong(dsize,fp);	fputLong(dic_bits,fp);	fputLong(code_bits,fp);	fputBitInit();	while(sdic.code_bgn != sdic.code_end){		getMatchPattern(&sdic, &pos, &len);		if(len > 2){			putBits(fp,1,1);			putBits(fp,pos, dic_bits);			putBits(fp,len-3,code_bits);		}		else{			putBits(fp,0,1);			putBits(fp,sdic.buffer[sdic.code_bgn], 8);			len = 1;		}		for(i = 0; i < len; i++){			if(p < dsize)				insertCodeToDic(&sdic, data[p++]);			/*else{				if(dic < dsize)					sdic.dic_bgn = nextPos(sdic.dic_bgn, sdic.buf_size);			}*/			slideDic(&sdic);			}	}	flushBit(fp);	return 0;}